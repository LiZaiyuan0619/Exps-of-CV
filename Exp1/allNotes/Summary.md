# 关于wave的代码分析

**代码具体实现的功能是预加载一个已知的点云文件，满足实验的基本要求后还同时设置了可以选择本地的点云格式的文件实现相同的加载效果**

以下是思路分析

导入了包Three.js的相关包：本次实验相关的有  Threejs | OrbitControls | PCDLoader | GUI

常见的初始设置：设置Threejs里面的场景、相机、渲染器，这里的套路是，设置相机后就设置他的位置，设置渲染器后就设置他的渲染情况——整个窗口

**提出问题**

```
解释Threejs里面常见的场景  相机 渲染器等的作用？

当使用 Three.js 或类似的3D图形库时，通常会涉及到几个基本的概念，包括场景（Scene）、相机（Camera）、渲染器（Renderer）等。下面是对这些概念的简要解释：

1. **场景（Scene）：**
   - **作用：** 场景是包含所有要渲染对象的容器。它是一个抽象概念，用于组织和管理3D空间中的对象。
   - **使用：** 将所有的3D对象（例如模型、灯光、相机等）添加到场景中，然后场景会根据相机的位置和设置，以及光照等因素来渲染这些对象。

2. **相机（Camera）：**
   - **作用：** 相机定义了场景的可视范围，并决定了哪些部分将被渲染到屏幕上。它相当于观察者的眼睛，决定了观察场景的视角和方式。
   - **使用：** 通过设置相机的位置、视角、投影方式等参数，来调整观察场景的效果。Three.js提供了不同类型的相机，如透视相机（PerspectiveCamera）和正交相机（OrthographicCamera）。

3. **渲染器（Renderer）：**
   - **作用：** 渲染器负责将场景和相机中的3D对象转换为2D图像，最终在屏幕上呈现出来。
   - **使用：** 创建一个渲染器实例，然后将其连接到HTML文档中的某个元素，如 `<div>`。渲染器通常支持设置渲染的尺寸、背景颜色等属性，然后使用 `render` 方法将场景渲染到屏幕上。

4. **光源（Light）：**
   - **作用：** 光源用于定义场景中的光照条件。Three.js 提供了多种类型的光源，包括环境光、点光源、聚光灯等。
   - **使用：** 将光源对象添加到场景中，然后设置其光照属性，如颜色、强度等。

这些概念一起协同工作，使得在浏览器中创建和呈现3D场景变得相对简单。在使用 Three.js 时，你会配置这些元素，将它们组合在一起以构建所需的3D场景，并使用相机、渲染器等组件来实现用户所见的效果。
```

---

```
为什么要设置多个相机？

在 Three.js 或其他3D图形库中，设置多个相机的常见原因包括：

不同视角和观察角度： 多个相机可以用于创建不同的视角和观察角度。这对于在同一场景中展示不同的视图或让用户从不同的角度查看场景非常有用。例如，一个相机可以用于整体场景的俯视，另一个相机用于近距离的细节查看。

渲染到不同的目标： 不同的相机可以用于渲染到不同的渲染目标或纹理。这可以用于创建镜子、屏幕空间效果或多重视点渲染等场景。

层次结构和复杂场景： 在复杂的3D场景中，可能有多个对象，每个对象需要不同的摄像机设置。例如，一个相机可能专门用于渲染前景，另一个用于渲染背景。

性能优化： 某些情况下，可以使用多个相机进行性能优化。例如，通过使用一个相机来渲染场景的静态部分，而另一个相机只渲染动态或交互性的部分，可以更有效地管理资源。

分屏或多视口： 在游戏或VR应用中，可能需要使用多个相机来实现分屏或多视口效果，以为多个玩家或用户提供独立的视图。
```

----

接下来便是设置主体页面内容，我们设置了标题，对它进行位置、颜色等处理后，从而对用户提供了一些说明

设置了OrbitControls从而可以使用鼠标和触摸设备来交互式地控制相机；

设置了isRotation从而可以控制某些条件或状态；

设置了GUI从而可以在网页上创建交互式的用户界面；

设置了“点云设置”的文件夹，从而可以组织和分类 GUI 中的控制元素

设置（添加）了四个透视摄像机，并且对他们进行了变换矩阵的处理，包括平移、旋转和缩放，**注意这一步骤的原因在于wave个人的点云重建的处理，变换矩阵可能是来自于综设的中间结果，这样做更好地还原了综设的点云的重建**

我们定义了resetGUI()：重置（或重新初始化）之前创建的 dat.GUI 实例

现在我们终于开始功能的主要部分，创建了点云加载器后，加载wave传入的初始点云文件，并执行回调函数：点云的旋转，点云材质处理，点云添加到场景中，四个摄像机添加到场景中，四个摄像机指向点云，创建GUI“点云0”文件夹从而用户可以控制该点云文件的加载情况，包括点数、点的大小、点的颜色等

然而，这里仅仅是处理到了个人点云文件的加载，我们还想要让用户可以选择自己的文件加载

我们先设置用户传入点云文件的预处理，具体来说包括设置按钮，添加按钮，提供说明，设置选择文件夹，限制文件格式

用户一旦选择文件后，触发事件处理函数（ onchange() ）：获取文件列表（因为可以传入多个文件），重置场景，移除相机，然后开始循环处理文件列表（如果仅仅传入了一个文件就进行下面的一次操作就可以），读取当前的单个文件，转换为Data URL，文件读取完成后触发事件处理函数，设置点云位置，设置点云材质，加载点云材质到点云，所有点云数据都加载完成后添加点云到场景，为每一个点云创建GUI控件，最后是设置相机位置

我们还需要做一些收尾工作，包括对于窗口改变的处理函数——调整窗口大小，更新投影矩阵和相机纵横比；以及递归调用动画函数，实现点云的不断旋转

# 关于Bian的代码分析

**首先需要明确的是除了Wave外其他人都是使用正常的HTML语言，明显的是各种<>标签**

Bian在head部分首先设置了标题，设置了style标签内包含了一些CSS的样式规则，body元素的外边距和canvas的宽高，充满了整个视口，并且导入了各种库

编写body部分，设置了一些按钮，使用回调函数来设置按钮实现的功能；此外我们还导入了库中的类等部分；定义3D图像，几何体，基础材质，网格，添加网格图像到3D容器，显示坐标轴，并且设置按钮的回调函数

设置场景、相机、渲染器，以及设置渲染器的大小，添加渲染元素到文档body中

创建地面几何体，基础材质，网格对象，最后将这个地面图像旋转处理后添加到场景中

设置相机位置，相机助手，添加相机助手

创建轨道控制器从而允许用户通过鼠标控制相机的位置和方向，同时设置了阻尼效果和缩放功能

现在我们开始加载点云，创建PCDLoader类的对象，加载路径指定的pcd文件，回调函数中我们设置点云大小和颜色，旋转处理后设置位置，然后把之前定义的一堆相机和坐标轴辅助器添加到场景中，同时调用动画函数（函数内部是循环调用本函数，开始渲染，更新鼠标的控制，同时阴影映射，最后是绕轴旋转）：让它开始旋转。

接下来是我们设置加载资源时的回调函数，处理加载过程中出现的错误，加载进程进度

重复加载一次点云

——End

# 关于王嘉楠的代码分析

在head部分通过meta标签定义了文档的字符集编码方式，浏览器解释文档的方式和文档的类型；同时还设置了标题，页面边距和canvas元素；以及ID选择器，内容包括宽高，背景颜色，文本颜色，行高

在style部分，设置了需要导入部分的预准备部分

body部分先用div设置了进度条和颜色的同名元素（用于设置颜色），导入了类和包，设置了场景和高宽，相机及位置。这里我们用相机复制器来显示相机并添加到场景中，设置渲染器及大小、颜色，这里还设置了点光源以及位置，设置了辅助坐标系，添加虚拟摄像机（创建几何体、网格、材质），现在我们开始加载点云，设置摄像机的朝向、纹理、材质、点云大小、颜色，添加了一个点击事件监听器，当点击这个元素时执行回调函数从而可以改变不同颜色，定义渲染函数（先循环调用，场景渲染，旋转图像，摄像机的旋转和朝向）在加载点云函数的的最后定义进度函数和错误处理函数

重复上面的加载点云函数，因为我们需要执行两次加载点云

# 关于李俊呈的代码分析

在head部分定义标题，内部的script导入库的预处理，内部的script还进行了：导入库和类，定义了场景、渲染器、相机、交互控制，添加渲染器，还定义了网格辅助对象，又设置了虚拟透视相机并添加到场景中，现在我们开始加载点云：通过时间来控制旋转，设置旋转半径，创建环境光，添加点光源，设置点的各方面细节，同时我们还要设置交互界面，添加控制点云的处理，最后是调用动画函数，这里就是简单的循环、更新控制器和重新渲染

body部分为空

# 关于杨朝的代码分析

head部分设置了语言、标题、编码方式和视口信息

在body部分，内部的script部分导入映射脚本，包模块脚本，，这里把一系列设置塞进到以恶搞init函数：设置渲染器，渲染器的分辨率和大小和窗口相适应，设置了相机和i相机辅助器，设置了点光源，设置了交互模块，设置了加载器，设置了gui调节和动画函数，我们加载了三个点云后还做了另外的一些处理，就是窗口大小适应的调整函数以及渲染函数

# 关于许秩群的代码分析

在head部分设置编码方式，标题，style部分设置页面基础设置比如边距、背景等，body部分设置了用于加载点云的按钮，通过回调函数直接加载包装好的函数，div模块定义了点云的颜色，script部分设置了源包，接下来的script就是正常的的设置场景、渲染器、光源、控制器、相机，注意这里<u>蛮有新意的：用按钮实现了控制自动旋转的继续和停止</u>，把加载点云的各个步骤包装成为了以恶搞函数，内容是设置点云几何体、材质、点云对象，启用阴影映射，设置缩放因子，并添加点云到场景中，添加大小滑块时间的监听器，添加颜色控制，胜场随机颜色。

<u>注意本文件实现了加载指定（本地）点云文件的功能</u>，也是包装成了一个函数，先移除点云对象，规定输入的文件格式，调用加载用户点云的函数。最后还定义了动画函数

# 关于王圳洋的代码分析

在head部分，设置了标题，各种按钮以及样式，编码方式，并且导入了网页所需要的favicon 图标和 CSS 样式文件

在body部分，主要还是包装多个步骤到一个init函数，包括：设置场景、渲染器、相机、辅助相机和交互控制；还定义了加载点云函数，

**<u>注意这部分代码需要重新分析，内容并不简单，似有高人指点</u>**

# 关于黄一诺的代码分析

**<u>这部分代码也是需要重新分析，有一些内容从未见过，比如平行光，同时程序的耦合性也很小，很是规范</u>**